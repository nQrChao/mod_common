[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"water-wave",[{"hash":708384910,"record":null,"name":"water-wave|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n uniform Properties {\n    vec4 colors[6];\n    vec4 heights[6];\n    vec2 iResult;\n    float tiltAngle;\n    float corrugationType;\n};\nvec2 tranPt(vec2 uv, float angle, vec2 center) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float Ox = center.x;\n    float Oy = center.y;\n    mat3 m = mat3(\n        c, -s, (1.0-c)*Ox + s*Oy,\n        s, c, (1.0-c)*Oy - s*Ox,\n        0.0, 0.0, 1.0\n    );\n    vec3 ret = m * vec3(uv.x, uv.y, 1.0);\n    return ret.xy;\n}\nfloat drawWater(vec2 uv, float angle, float _height) {\n    float ratio = iResult.y/iResult.x;\n    bool toLeft = sin(angle) >= 0.0;\n    vec2 center = vec2(0.5, 1.0-_height);\n    float _t = abs(tan(angle));\n    if(_height < 0.5) {\n        bool is_bottom = _t/ratio > 2.0*_height;\n        if(is_bottom) {\n            center.x = sqrt(2.0*_height/_t*ratio)/2.0;\n            center.y = 1.0 - sqrt(2.0*_height*_t/ratio)/2.0;\n            bool is_top = _t > (ratio)/(_height*2.0);\n            if(is_top) {\n                center.y = 0.5;\n                center.x = _height;\n            }\n        }\n        if(!toLeft) center.x = 1.0-center.x;\n    } else {\n        bool is_top = _t > 2.0*ratio*(1.0-_height);\n        if(is_top) {\n            center.x = sqrt(2.0*ratio*(1.0-_height)/_t)/2.0;\n            center.y = sqrt(2.0*ratio*(1.0-_height)*_t)/2.0/ratio;\n            bool is_bottom = _t > ratio/(2.0*(1.0-_height));\n            if(is_bottom) {\n                center.y = 0.5;\n                center.x = 1.0-_height;\n            }\n        }\n        if(toLeft) center.x = 1.0-center.x;\n    }\n    uv.y *= ratio;\n    uv -= vec2(center.x, center.y*ratio);\n    vec2 uv1 = tranPt(uv, angle, vec2(0.0));\n    float y = 0.0;\n    float absX = abs(uv1.x);\n    if(corrugationType == 0.0 || corrugationType == 1.0) {\n        float baseCurve = 0.15 * (1.0 - pow(2.0*absX, 2.0));\n        y += baseCurve;\n    }\n    float edge = uv1.y - y;\n    return smoothstep(-0.015, 0.015, edge);\n}\nfloat drawEllipse(vec2 uv, float angle, float _height) {\n    float ratio = iResult.y/iResult.x;\n    vec2 center = vec2(0.5, 1.0 - _height);\n    uv.y *= ratio;\n    uv -= vec2(center.x, center.y*ratio);\n    vec2 uv1 = tranPt(uv, angle, vec2(0.0));\n    float a = 0.5;\n    float b = a * 0.4;\n    float ellipse = 1.0 - (pow(uv1.x/a, 2.0) + pow(uv1.y/b, 2.0));\n    return smoothstep(-0.02, 0.02, ellipse);\n}\nvoid main() {\n    vec4 ret = texture(texture, v_uv0);\n    if(ret.a == 0.0) discard;\n    float angle = mod(tiltAngle,360.0) * 3.14159265358979323846 / 180.0;\n    vec2 uv = v_uv0;\n    float _height = 0.0;\n    int lastValidIndex = 0;\n    for(int i=0; i<6; i++) {\n        if(heights[i].x >= 0.001) {\n            lastValidIndex = i;\n            _height += heights[i].x;\n            float water = drawWater(uv, angle, _height);\n            if(water > 0.0) {\n                ret = mix(ret, colors[i], water);\n                break;\n            }\n        }\n    }\n    if(corrugationType == 0.0 || corrugationType == 1.0) {\n    float ellipse = drawEllipse(uv, angle, _height);\n    if(ellipse > 0.0) {\n        vec4 ellipseColor;\n        if(lastValidIndex == 0) ellipseColor = colors[0];\n        else if(lastValidIndex == 1) ellipseColor = colors[1];\n        else if(lastValidIndex == 2) ellipseColor = colors[2];\n        else if(lastValidIndex == 3) ellipseColor = colors[3];\n        else if(lastValidIndex == 4) ellipseColor = colors[4];\n        else if(lastValidIndex == 5) ellipseColor = colors[5];\n        ellipseColor.rgb *= 0.7;\n        ret = mix(ret, ellipseColor, ellipse * 0.8);\n    }\n}\n    if(ret.r > 0.99 && ret.g > 0.99 && ret.b > 0.99) discard;\n    gl_FragColor = ret;\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n#endif\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n uniform vec4 colors[6];\nuniform vec4 heights[6];\nuniform vec2 iResult;\nuniform float tiltAngle;\nuniform float corrugationType;\nvec2 tranPt(vec2 uv, float angle, vec2 center) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float Ox = center.x;\n    float Oy = center.y;\n    mat3 m = mat3(\n        c, -s, (1.0-c)*Ox + s*Oy,\n        s, c, (1.0-c)*Oy - s*Ox,\n        0.0, 0.0, 1.0\n    );\n    vec3 ret = m * vec3(uv.x, uv.y, 1.0);\n    return ret.xy;\n}\nfloat drawWater(vec2 uv, float angle, float _height) {\n    float ratio = iResult.y/iResult.x;\n    bool toLeft = sin(angle) >= 0.0;\n    vec2 center = vec2(0.5, 1.0-_height);\n    float _t = abs(tan(angle));\n    if(_height < 0.5) {\n        bool is_bottom = _t/ratio > 2.0*_height;\n        if(is_bottom) {\n            center.x = sqrt(2.0*_height/_t*ratio)/2.0;\n            center.y = 1.0 - sqrt(2.0*_height*_t/ratio)/2.0;\n            bool is_top = _t > (ratio)/(_height*2.0);\n            if(is_top) {\n                center.y = 0.5;\n                center.x = _height;\n            }\n        }\n        if(!toLeft) center.x = 1.0-center.x;\n    } else {\n        bool is_top = _t > 2.0*ratio*(1.0-_height);\n        if(is_top) {\n            center.x = sqrt(2.0*ratio*(1.0-_height)/_t)/2.0;\n            center.y = sqrt(2.0*ratio*(1.0-_height)*_t)/2.0/ratio;\n            bool is_bottom = _t > ratio/(2.0*(1.0-_height));\n            if(is_bottom) {\n                center.y = 0.5;\n                center.x = 1.0-_height;\n            }\n        }\n        if(toLeft) center.x = 1.0-center.x;\n    }\n    uv.y *= ratio;\n    uv -= vec2(center.x, center.y*ratio);\n    vec2 uv1 = tranPt(uv, angle, vec2(0.0));\n    float y = 0.0;\n    float absX = abs(uv1.x);\n    if(corrugationType == 0.0 || corrugationType == 1.0) {\n        float baseCurve = 0.15 * (1.0 - pow(2.0*absX, 2.0));\n        y += baseCurve;\n    }\n    float edge = uv1.y - y;\n    return smoothstep(-0.015, 0.015, edge);\n}\nfloat drawEllipse(vec2 uv, float angle, float _height) {\n    float ratio = iResult.y/iResult.x;\n    vec2 center = vec2(0.5, 1.0 - _height);\n    uv.y *= ratio;\n    uv -= vec2(center.x, center.y*ratio);\n    vec2 uv1 = tranPt(uv, angle, vec2(0.0));\n    float a = 0.5;\n    float b = a * 0.4;\n    float ellipse = 1.0 - (pow(uv1.x/a, 2.0) + pow(uv1.y/b, 2.0));\n    return smoothstep(-0.02, 0.02, ellipse);\n}\nvoid main() {\n    vec4 ret = texture2D(texture, v_uv0);\n    if(ret.a == 0.0) discard;\n    float angle = mod(tiltAngle,360.0) * 3.14159265358979323846 / 180.0;\n    vec2 uv = v_uv0;\n    float _height = 0.0;\n    int lastValidIndex = 0;\n    for(int i=0; i<6; i++) {\n        if(heights[i].x >= 0.001) {\n            lastValidIndex = i;\n            _height += heights[i].x;\n            float water = drawWater(uv, angle, _height);\n            if(water > 0.0) {\n                ret = mix(ret, colors[i], water);\n                break;\n            }\n        }\n    }\n    if(corrugationType == 0.0 || corrugationType == 1.0) {\n    float ellipse = drawEllipse(uv, angle, _height);\n    if(ellipse > 0.0) {\n        vec4 ellipseColor;\n        if(lastValidIndex == 0) ellipseColor = colors[0];\n        else if(lastValidIndex == 1) ellipseColor = colors[1];\n        else if(lastValidIndex == 2) ellipseColor = colors[2];\n        else if(lastValidIndex == 3) ellipseColor = colors[3];\n        else if(lastValidIndex == 4) ellipseColor = colors[4];\n        else if(lastValidIndex == 5) ellipseColor = colors[5];\n        ellipseColor.rgb *= 0.7;\n        ret = mix(ret, ellipseColor, ellipse * 0.8);\n    }\n}\n    if(ret.r > 0.99 && ret.g > 0.99 && ret.b > 0.99) discard;\n    gl_FragColor = ret;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"Properties","binding":1,"members":[{"name":"colors","type":16,"count":6},{"name":"heights","type":16,"count":6},{"name":"iResult","type":14,"count":1},{"name":"tiltAngle","type":13,"count":1},{"name":"corrugationType","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"water-wave|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]}}}]}]]],0,0,[],[],[]]